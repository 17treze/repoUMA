import { BehaviorSubject, Observable, Subject } from 'rxjs';
import { StompConfig } from './stomp.config';
import * as Stomp from '@stomp/stompjs';
import { StompHeaders } from './stomp-headers';
import { StompState } from './stomp-state';
/**
 * Angular2 STOMP Raw Service using @stomp/stomp.js
 *
 * You will only need the public properties and
 * methods listed unless you are an advanced user. This service handles subscribing to a
 * message queue using the stomp.js library, and returns
 * values via the ES6 Observable specification for
 * asynchronous value streaming by wiring the STOMP
 * messages into an observable.
 *
 * If you will like to pass the configuration as a dependency,
 * please use StompService class.
 */
import * as ɵngcc0 from '@angular/core';
export declare class StompRService {
    /**
     * State of the STOMPService
     *
     * It is a BehaviorSubject and will emit current status immediately. This will typically get
     * used to show current status to the end user.
     */
    state: BehaviorSubject<StompState>;
    /**
     * Will trigger when connection is established. Use this to carry out initialization.
     * It will trigger every time a (re)connection occurs. If it is already connected
     * it will trigger immediately. You can safely ignore the value, as it will always be
     * StompState.CONNECTED
     */
    connectObservable: Observable<StompState>;
    /**
     * Provides headers from most recent connection to the server as return by the CONNECTED
     * frame.
     * If the STOMP connection has already been established it will trigger immediately.
     * It will additionally trigger in event of reconnection, the value will be set of headers from
     * the recent server response.
     */
    serverHeadersObservable: Observable<StompHeaders>;
    private _serverHeadersBehaviourSubject;
    /**
     * Will emit all messages to the default queue (any message that are not handled by a subscription)
     */
    defaultMessagesObservable: Subject<Stomp.Message>;
    /**
     * Will emit all receipts
     */
    receiptsObservable: Subject<Stomp.Frame>;
    /**
     * Will trigger when an error occurs. This Subject can be used to handle errors from
     * the stomp broker.
     */
    errorSubject: Subject<string | Stomp.Message>;
    /**
     * Internal array to hold locally queued messages when STOMP broker is not connected.
     */
    protected queuedMessages: {
        queueName: string;
        message: string;
        headers: StompHeaders;
    }[];
    /**
     * Configuration
     */
    private _config;
    /**
     * STOMP Client from @stomp/stomp.js
     */
    protected client: Stomp.Client;
    /**
     * Constructor
     *
     * See README and samples for configuration examples
     */
    constructor();
    /** Set configuration */
    config: StompConfig;
    /** It will initialize STOMP Client. */
    protected initStompClient(): void;
    /**
     * It will connect to the STOMP broker.
     */
    initAndConnect(): void;
    /**
     * It will disconnect from the STOMP broker.
     */
    disconnect(): void;
    /**
     * It will return `true` if STOMP broker is connected and `false` otherwise.
     */
    connected(): boolean;
    /**
     * It will send a message to a named destination. The message must be `string`.
     *
     * The message will get locally queued if the STOMP broker is not connected. It will attempt to
     * publish queued messages as soon as the broker gets connected.
     *
     * @param queueName
     * @param message
     * @param headers
     */
    publish(queueName: string, message: string, headers?: StompHeaders): void;
    /** It will send queued messages. */
    protected sendQueuedMessages(): void;
    /**
     * It will subscribe to server message queues
     *
     * This method can be safely called even if the STOMP broker is not connected.
     * If the underlying STOMP connection drops and reconnects, it will resubscribe automatically.
     *
     * If a header field 'ack' is not explicitly passed, 'ack' will be set to 'auto'. If you
     * do not understand what it means, please leave it as is.
     *
     * Note that when working with temporary queues where the subscription request
     * creates the
     * underlying queue, mssages might be missed during reconnect. This issue is not specific
     * to this library but the way STOMP brokers are designed to work.
     *
     * @param queueName
     * @param headers
     */
    subscribe(queueName: string, headers?: StompHeaders): Observable<Stomp.Message>;
    /**
     * It will handle messages received in the default queue. Messages that would not be handled otherwise
     * get delivered to the default queue.
     */
    protected setupOnReceive(): void;
    /**
     * It will emit all receipts.
     */
    protected setupReceipts(): void;
    /**
     * Wait for receipt, this indicates that server has carried out the related operation
     */
    waitForReceipt(receiptId: string, callback: (frame: Stomp.Frame) => void): void;
    /**
     * Callback Functions
     *
     * Note the method signature: () => preserves lexical scope
     * if we need to use this.x inside the function
     */
    protected debug: (args: any) => void;
    /** Callback run on successfully connecting to server */
    protected on_connect: (frame: Stomp.Frame) => void;
    /** Handle errors from stomp.js */
    protected on_error: (error: string | Stomp.Message) => void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<StompRService, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<StompRService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvbXAtci5zZXJ2aWNlLmQudHMiLCJzb3VyY2VzIjpbInN0b21wLXIuc2VydmljZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN0b21wQ29uZmlnIH0gZnJvbSAnLi9zdG9tcC5jb25maWcnO1xuaW1wb3J0ICogYXMgU3RvbXAgZnJvbSAnQHN0b21wL3N0b21wanMnO1xuaW1wb3J0IHsgU3RvbXBIZWFkZXJzIH0gZnJvbSAnLi9zdG9tcC1oZWFkZXJzJztcbmltcG9ydCB7IFN0b21wU3RhdGUgfSBmcm9tICcuL3N0b21wLXN0YXRlJztcbi8qKlxuICogQW5ndWxhcjIgU1RPTVAgUmF3IFNlcnZpY2UgdXNpbmcgQHN0b21wL3N0b21wLmpzXG4gKlxuICogWW91IHdpbGwgb25seSBuZWVkIHRoZSBwdWJsaWMgcHJvcGVydGllcyBhbmRcbiAqIG1ldGhvZHMgbGlzdGVkIHVubGVzcyB5b3UgYXJlIGFuIGFkdmFuY2VkIHVzZXIuIFRoaXMgc2VydmljZSBoYW5kbGVzIHN1YnNjcmliaW5nIHRvIGFcbiAqIG1lc3NhZ2UgcXVldWUgdXNpbmcgdGhlIHN0b21wLmpzIGxpYnJhcnksIGFuZCByZXR1cm5zXG4gKiB2YWx1ZXMgdmlhIHRoZSBFUzYgT2JzZXJ2YWJsZSBzcGVjaWZpY2F0aW9uIGZvclxuICogYXN5bmNocm9ub3VzIHZhbHVlIHN0cmVhbWluZyBieSB3aXJpbmcgdGhlIFNUT01QXG4gKiBtZXNzYWdlcyBpbnRvIGFuIG9ic2VydmFibGUuXG4gKlxuICogSWYgeW91IHdpbGwgbGlrZSB0byBwYXNzIHRoZSBjb25maWd1cmF0aW9uIGFzIGEgZGVwZW5kZW5jeSxcbiAqIHBsZWFzZSB1c2UgU3RvbXBTZXJ2aWNlIGNsYXNzLlxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBTdG9tcFJTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBTdGF0ZSBvZiB0aGUgU1RPTVBTZXJ2aWNlXG4gICAgICpcbiAgICAgKiBJdCBpcyBhIEJlaGF2aW9yU3ViamVjdCBhbmQgd2lsbCBlbWl0IGN1cnJlbnQgc3RhdHVzIGltbWVkaWF0ZWx5LiBUaGlzIHdpbGwgdHlwaWNhbGx5IGdldFxuICAgICAqIHVzZWQgdG8gc2hvdyBjdXJyZW50IHN0YXR1cyB0byB0aGUgZW5kIHVzZXIuXG4gICAgICovXG4gICAgc3RhdGU6IEJlaGF2aW9yU3ViamVjdDxTdG9tcFN0YXRlPjtcbiAgICAvKipcbiAgICAgKiBXaWxsIHRyaWdnZXIgd2hlbiBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLiBVc2UgdGhpcyB0byBjYXJyeSBvdXQgaW5pdGlhbGl6YXRpb24uXG4gICAgICogSXQgd2lsbCB0cmlnZ2VyIGV2ZXJ5IHRpbWUgYSAocmUpY29ubmVjdGlvbiBvY2N1cnMuIElmIGl0IGlzIGFscmVhZHkgY29ubmVjdGVkXG4gICAgICogaXQgd2lsbCB0cmlnZ2VyIGltbWVkaWF0ZWx5LiBZb3UgY2FuIHNhZmVseSBpZ25vcmUgdGhlIHZhbHVlLCBhcyBpdCB3aWxsIGFsd2F5cyBiZVxuICAgICAqIFN0b21wU3RhdGUuQ09OTkVDVEVEXG4gICAgICovXG4gICAgY29ubmVjdE9ic2VydmFibGU6IE9ic2VydmFibGU8U3RvbXBTdGF0ZT47XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgaGVhZGVycyBmcm9tIG1vc3QgcmVjZW50IGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciBhcyByZXR1cm4gYnkgdGhlIENPTk5FQ1RFRFxuICAgICAqIGZyYW1lLlxuICAgICAqIElmIHRoZSBTVE9NUCBjb25uZWN0aW9uIGhhcyBhbHJlYWR5IGJlZW4gZXN0YWJsaXNoZWQgaXQgd2lsbCB0cmlnZ2VyIGltbWVkaWF0ZWx5LlxuICAgICAqIEl0IHdpbGwgYWRkaXRpb25hbGx5IHRyaWdnZXIgaW4gZXZlbnQgb2YgcmVjb25uZWN0aW9uLCB0aGUgdmFsdWUgd2lsbCBiZSBzZXQgb2YgaGVhZGVycyBmcm9tXG4gICAgICogdGhlIHJlY2VudCBzZXJ2ZXIgcmVzcG9uc2UuXG4gICAgICovXG4gICAgc2VydmVySGVhZGVyc09ic2VydmFibGU6IE9ic2VydmFibGU8U3RvbXBIZWFkZXJzPjtcbiAgICBwcml2YXRlIF9zZXJ2ZXJIZWFkZXJzQmVoYXZpb3VyU3ViamVjdDtcbiAgICAvKipcbiAgICAgKiBXaWxsIGVtaXQgYWxsIG1lc3NhZ2VzIHRvIHRoZSBkZWZhdWx0IHF1ZXVlIChhbnkgbWVzc2FnZSB0aGF0IGFyZSBub3QgaGFuZGxlZCBieSBhIHN1YnNjcmlwdGlvbilcbiAgICAgKi9cbiAgICBkZWZhdWx0TWVzc2FnZXNPYnNlcnZhYmxlOiBTdWJqZWN0PFN0b21wLk1lc3NhZ2U+O1xuICAgIC8qKlxuICAgICAqIFdpbGwgZW1pdCBhbGwgcmVjZWlwdHNcbiAgICAgKi9cbiAgICByZWNlaXB0c09ic2VydmFibGU6IFN1YmplY3Q8U3RvbXAuRnJhbWU+O1xuICAgIC8qKlxuICAgICAqIFdpbGwgdHJpZ2dlciB3aGVuIGFuIGVycm9yIG9jY3Vycy4gVGhpcyBTdWJqZWN0IGNhbiBiZSB1c2VkIHRvIGhhbmRsZSBlcnJvcnMgZnJvbVxuICAgICAqIHRoZSBzdG9tcCBicm9rZXIuXG4gICAgICovXG4gICAgZXJyb3JTdWJqZWN0OiBTdWJqZWN0PHN0cmluZyB8IFN0b21wLk1lc3NhZ2U+O1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIGFycmF5IHRvIGhvbGQgbG9jYWxseSBxdWV1ZWQgbWVzc2FnZXMgd2hlbiBTVE9NUCBicm9rZXIgaXMgbm90IGNvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcXVldWVkTWVzc2FnZXM6IHtcbiAgICAgICAgcXVldWVOYW1lOiBzdHJpbmc7XG4gICAgICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICAgICAgaGVhZGVyczogU3RvbXBIZWFkZXJzO1xuICAgIH1bXTtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSBfY29uZmlnO1xuICAgIC8qKlxuICAgICAqIFNUT01QIENsaWVudCBmcm9tIEBzdG9tcC9zdG9tcC5qc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBjbGllbnQ6IFN0b21wLkNsaWVudDtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogU2VlIFJFQURNRSBhbmQgc2FtcGxlcyBmb3IgY29uZmlndXJhdGlvbiBleGFtcGxlc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCk7XG4gICAgLyoqIFNldCBjb25maWd1cmF0aW9uICovXG4gICAgY29uZmlnOiBTdG9tcENvbmZpZztcbiAgICAvKiogSXQgd2lsbCBpbml0aWFsaXplIFNUT01QIENsaWVudC4gKi9cbiAgICBwcm90ZWN0ZWQgaW5pdFN0b21wQ2xpZW50KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogSXQgd2lsbCBjb25uZWN0IHRvIHRoZSBTVE9NUCBicm9rZXIuXG4gICAgICovXG4gICAgaW5pdEFuZENvbm5lY3QoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBJdCB3aWxsIGRpc2Nvbm5lY3QgZnJvbSB0aGUgU1RPTVAgYnJva2VyLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBJdCB3aWxsIHJldHVybiBgdHJ1ZWAgaWYgU1RPTVAgYnJva2VyIGlzIGNvbm5lY3RlZCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgY29ubmVjdGVkKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSXQgd2lsbCBzZW5kIGEgbWVzc2FnZSB0byBhIG5hbWVkIGRlc3RpbmF0aW9uLiBUaGUgbWVzc2FnZSBtdXN0IGJlIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogVGhlIG1lc3NhZ2Ugd2lsbCBnZXQgbG9jYWxseSBxdWV1ZWQgaWYgdGhlIFNUT01QIGJyb2tlciBpcyBub3QgY29ubmVjdGVkLiBJdCB3aWxsIGF0dGVtcHQgdG9cbiAgICAgKiBwdWJsaXNoIHF1ZXVlZCBtZXNzYWdlcyBhcyBzb29uIGFzIHRoZSBicm9rZXIgZ2V0cyBjb25uZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcXVldWVOYW1lXG4gICAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gaGVhZGVyc1xuICAgICAqL1xuICAgIHB1Ymxpc2gocXVldWVOYW1lOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZywgaGVhZGVycz86IFN0b21wSGVhZGVycyk6IHZvaWQ7XG4gICAgLyoqIEl0IHdpbGwgc2VuZCBxdWV1ZWQgbWVzc2FnZXMuICovXG4gICAgcHJvdGVjdGVkIHNlbmRRdWV1ZWRNZXNzYWdlcygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEl0IHdpbGwgc3Vic2NyaWJlIHRvIHNlcnZlciBtZXNzYWdlIHF1ZXVlc1xuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIHNhZmVseSBjYWxsZWQgZXZlbiBpZiB0aGUgU1RPTVAgYnJva2VyIGlzIG5vdCBjb25uZWN0ZWQuXG4gICAgICogSWYgdGhlIHVuZGVybHlpbmcgU1RPTVAgY29ubmVjdGlvbiBkcm9wcyBhbmQgcmVjb25uZWN0cywgaXQgd2lsbCByZXN1YnNjcmliZSBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogSWYgYSBoZWFkZXIgZmllbGQgJ2FjaycgaXMgbm90IGV4cGxpY2l0bHkgcGFzc2VkLCAnYWNrJyB3aWxsIGJlIHNldCB0byAnYXV0bycuIElmIHlvdVxuICAgICAqIGRvIG5vdCB1bmRlcnN0YW5kIHdoYXQgaXQgbWVhbnMsIHBsZWFzZSBsZWF2ZSBpdCBhcyBpcy5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB3aGVuIHdvcmtpbmcgd2l0aCB0ZW1wb3JhcnkgcXVldWVzIHdoZXJlIHRoZSBzdWJzY3JpcHRpb24gcmVxdWVzdFxuICAgICAqIGNyZWF0ZXMgdGhlXG4gICAgICogdW5kZXJseWluZyBxdWV1ZSwgbXNzYWdlcyBtaWdodCBiZSBtaXNzZWQgZHVyaW5nIHJlY29ubmVjdC4gVGhpcyBpc3N1ZSBpcyBub3Qgc3BlY2lmaWNcbiAgICAgKiB0byB0aGlzIGxpYnJhcnkgYnV0IHRoZSB3YXkgU1RPTVAgYnJva2VycyBhcmUgZGVzaWduZWQgdG8gd29yay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWV1ZU5hbWVcbiAgICAgKiBAcGFyYW0gaGVhZGVyc1xuICAgICAqL1xuICAgIHN1YnNjcmliZShxdWV1ZU5hbWU6IHN0cmluZywgaGVhZGVycz86IFN0b21wSGVhZGVycyk6IE9ic2VydmFibGU8U3RvbXAuTWVzc2FnZT47XG4gICAgLyoqXG4gICAgICogSXQgd2lsbCBoYW5kbGUgbWVzc2FnZXMgcmVjZWl2ZWQgaW4gdGhlIGRlZmF1bHQgcXVldWUuIE1lc3NhZ2VzIHRoYXQgd291bGQgbm90IGJlIGhhbmRsZWQgb3RoZXJ3aXNlXG4gICAgICogZ2V0IGRlbGl2ZXJlZCB0byB0aGUgZGVmYXVsdCBxdWV1ZS5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc2V0dXBPblJlY2VpdmUoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBJdCB3aWxsIGVtaXQgYWxsIHJlY2VpcHRzLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzZXR1cFJlY2VpcHRzKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogV2FpdCBmb3IgcmVjZWlwdCwgdGhpcyBpbmRpY2F0ZXMgdGhhdCBzZXJ2ZXIgaGFzIGNhcnJpZWQgb3V0IHRoZSByZWxhdGVkIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHdhaXRGb3JSZWNlaXB0KHJlY2VpcHRJZDogc3RyaW5nLCBjYWxsYmFjazogKGZyYW1lOiBTdG9tcC5GcmFtZSkgPT4gdm9pZCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgRnVuY3Rpb25zXG4gICAgICpcbiAgICAgKiBOb3RlIHRoZSBtZXRob2Qgc2lnbmF0dXJlOiAoKSA9PiBwcmVzZXJ2ZXMgbGV4aWNhbCBzY29wZVxuICAgICAqIGlmIHdlIG5lZWQgdG8gdXNlIHRoaXMueCBpbnNpZGUgdGhlIGZ1bmN0aW9uXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRlYnVnOiAoYXJnczogYW55KSA9PiB2b2lkO1xuICAgIC8qKiBDYWxsYmFjayBydW4gb24gc3VjY2Vzc2Z1bGx5IGNvbm5lY3RpbmcgdG8gc2VydmVyICovXG4gICAgcHJvdGVjdGVkIG9uX2Nvbm5lY3Q6IChmcmFtZTogU3RvbXAuRnJhbWUpID0+IHZvaWQ7XG4gICAgLyoqIEhhbmRsZSBlcnJvcnMgZnJvbSBzdG9tcC5qcyAqL1xuICAgIHByb3RlY3RlZCBvbl9lcnJvcjogKGVycm9yOiBzdHJpbmcgfCBTdG9tcC5NZXNzYWdlKSA9PiB2b2lkO1xufVxuIl19